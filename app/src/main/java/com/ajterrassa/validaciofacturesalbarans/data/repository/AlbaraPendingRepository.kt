package com.ajterrassa.validaciofacturesalbarans.data.repoimport android.content.Contextimport android.graphics.Bitmapimport android.graphics.BitmapFactoryimport android.util.Logimport com.ajterrassa.validaciofacturesalbarans.data.local.*import com.ajterrassa.validaciofacturesalbarans.data.model.AlbaraCreateDtoimport com.ajterrassa.validaciofacturesalbarans.data.network.ApiClientimport com.google.gson.GsonBuilderimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.withContextimport kotlinx.coroutines.withTimeoutimport okhttp3.MediaType.Companion.toMediaTypeimport okhttp3.MultipartBodyimport okhttp3.RequestBodyimport okhttp3.RequestBody.Companion.asRequestBodyimport okhttp3.RequestBody.Companion.toRequestBodyimport java.io.Fileimport java.io.FileOutputStreamimport java.net.SocketTimeoutExceptionimport java.util.Localeclass AlbaraPendingRepository(val ctx: Context) {    val db = AppDb.get(ctx)    private val dao = db.pendingDao()    private val api = ApiClient.apiService    /** Desa com a PENDENT — fase 1 sense auto res. */    suspend fun enqueuePending(        file: File,        referencia: String,        data: String,        importTotal: Double,        proveidorId: Long    ): Long = withContext(Dispatchers.IO) {        val safe = ensureAllowedUploadFile(file, ctx.cacheDir)        val entity = PendingAlbaraEntity(            referencia = referencia,            data = data,            importTotal = importTotal,            proveidorId = proveidorId,            filePath = safe.absolutePath,            status = EstatPendent.PENDENT,            retries = 0,            lastError = null,            createdAt = System.currentTimeMillis()        )        dao.insert(entity)    }    /** Enviament manual: marca ENVIANT → si 200 OK = ENVIAT; si KO = ERROR. */    suspend fun tryUploadNow(        id: Long,        token: String    ): Boolean = withContext(Dispatchers.IO) {        val item = dao.get(id) ?: return@withContext false        dao.update(item.copy(status = EstatPendent.ENVIANT))        try {            withTimeout(60_000L) {                val resp = api.uploadAlbara(                    auth = "Bearer $token",                    jsonData = buildJsonBody(item),                    filePart = createMultipartFilePart("file", item.filePath)                ).execute()                Log.i("UPLOAD_ALBARA", "HTTP ${resp.code()} per id=$id")                if (resp.isSuccessful) {                    dao.update(item.copy(                        status = EstatPendent.ENVIAT,                        lastError = null                    ))                    true                } else {                    val serverMsg = try { resp.errorBody()?.string()?.take(2048) } catch (_: Exception) { null }                    dao.update(item.copy(                        status = EstatPendent.ERROR,                        retries = item.retries + 1,                        lastError = "HTTP ${resp.code()} · ${serverMsg ?: "sense cos d'error"}"                    ))                    false                }            }        } catch (e: SocketTimeoutException) {            dao.update(item.copy(                status = EstatPendent.ERROR,                retries = item.retries + 1,                lastError = "Timeout"            ))            false        } catch (e: Exception) {            dao.update(item.copy(                status = EstatPendent.ERROR,                retries = item.retries + 1,                lastError = e.message ?: "Error"            ))            false        }    }    /** Elimina el fitxer local i marca ELIMINAT (manté el registre a l’històric). */    suspend fun eliminarLocal(id: Long) = withContext(Dispatchers.IO) {        val item = dao.get(id) ?: return@withContext        item.filePath?.let { path ->            try { File(path).delete() } catch (_: Exception) {}        }        dao.update(item.copy(            status = EstatPendent.ELIMINAT,            filePath = null        ))    }    /** Helpers — JSON + fitxer multipart */    private fun buildJsonBody(item: PendingAlbaraEntity): RequestBody {        val dto = AlbaraCreateDto(            tipus = "ALBARA",            referenciaDocument = item.referencia,            data = item.data,            importTotal = item.importTotal,            estat = "PENDENT",            creadorId = getUserId(),            validatPerId = null,            proveidorId = item.proveidorId,            edificiId = null,            otsId = null,            facturaId = null,            fitxerAdjunt = null        )        val json = GsonBuilder().serializeNulls().create().toJson(dto)        Log.i("UPLOAD_ALBARA", "JSON data -> $json")        return json.toRequestBody("application/json; charset=utf-8".toMediaType())    }    private fun createMultipartFilePart(partName: String, filePath: String?): MultipartBody.Part {        val file = filePath?.let(::File)            ?: throw IllegalStateException("Sense fitxer per enviar")        val ext = file.name.substringAfterLast('.', "").lowercase()        val mime = when (ext) {            "jpg", "jpeg" -> "image/jpeg"            "png"         -> "image/png"            "pdf"         -> "application/pdf"            else          -> throw IllegalArgumentException("Tipus de fitxer no permès")        }        val body = file.asRequestBody(mime.toMediaType())        return MultipartBody.Part.createFormData(partName, file.name, body)    }    private fun getUserId(): Long {        val prefs = ctx.getSharedPreferences("auth", Context.MODE_PRIVATE)        return prefs.getInt("usuariId", 0).toLong()    }    // --- conversions i validacions de fitxers acceptats (JPG/PNG/PDF) ---    private fun String.extLower(): String = substringAfterLast('.', "").lowercase(Locale.ROOT)    private fun isAllowedExt(ext: String) = ext == "jpg" || ext == "jpeg" || ext == "png" || ext == "pdf"    private fun ensureAllowedUploadFile(src: File, cacheDir: File): File {        val ext = src.name.extLower()        if (isAllowedExt(ext)) return src        val bmp: Bitmap = BitmapFactory.decodeFile(src.absolutePath) ?: return src        val out = File(cacheDir, "upload_${System.currentTimeMillis()}.jpg")        FileOutputStream(out).use { fos -> bmp.compress(Bitmap.CompressFormat.JPEG, 90, fos) }        return out    }}